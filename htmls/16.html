<!DOCTYPE html>
<!-- source: http://jsbin.com/majeko/20 -->
<html>

<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r67/three.min.js"></script>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta charset="utf-8">
  <title>blind</title>
  <style id="jsbin-css">
    body, canvas {
  margin: 0;
  border: 0;
  padding: 0;
  background-color:black;
  cursor: crosshair;
}
canvas {
  position: fixed;
}
</style>
</head>

<body>
  <script id="jsbin-javascript">
    (function() {
  var Mouse, PI, abs, animloop, camera, canvas, cos, ctx, cubes, cubes2, distance, frame, geometry, hypotenuse, material, offset, renderer, resizeHandler, scene, seed, side, sidehypotenuse, sin, sqrt, start, t, x, xside, y, yside, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4;

  t = 0;

  start = Date.now();

  seed = Math.random() * 1000;

  frame = 0;

  PI = Math.PI;

  sin = function(a) {
    return Math.sin(a);
  };

  cos = function(a) {
    return Math.cos(a);
  };

  abs = function(a) {
    return Math.abs(a);
  };

  sqrt = function(a) {
    return Math.sqrt(a);
  };

  hypotenuse = function(a, b) {
    return Math.sqrt(a * a + b * b);
  };

  distance = function(x1, y1, x2, y2) {
    return hypotenuse(x2 - x1, y2 - y1);
  };

  scene = new THREE.Scene();

  camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -50 * 100, 30 * 1000);

  renderer = new THREE.WebGLRenderer();

  canvas = document.createElement('canvas');

  ctx = canvas.getContext('2d');

  (resizeHandler = function() {
    camera.left = canvas.left = window.innerWidth / -2;
    camera.right = canvas.right = window.innerWidth / 2;
    camera.bottom = canvas.bottom = window.innerHeight / -2;
    camera.top = canvas.top = window.innerHeight / 2;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    return canvas.hyp = hypotenuse(canvas.width, canvas.height);
  })();

  window.addEventListener('resize', resizeHandler, false);

  document.body.appendChild(renderer.domElement);

  Mouse = {
    down: false,
    held: 0,
    x: canvas.width / 2,
    y: canvas.height / 2,
    x0: 0,
    y0: 0,
    events: {
      move: function(e) {
        if ("touches" in e) {
          e.preventDefault();
          e = e.touches[0];
        }
        Mouse.x = (Mouse.x + e.pageX) * 0.5;
        Mouse.y = (Mouse.y + e.pageY) * 0.5;
        Mouse.x0 = Mouse.x - canvas.width / 2;
        return Mouse.y0 = Mouse.y - canvas.height / 2;
      },
      down: function(e) {
        return Mouse.down = !Mouse.down;
      },
      up: function(e) {
        return Mouse.down = !Mouse.down;
      }
    }
  };

  window.addEventListener('mousemove', Mouse.events.move, false);

  window.addEventListener('mousedown', Mouse.events.down, false);

  window.addEventListener('mouseup', Mouse.events.up, false);

  window.addEventListener('touchmove', Mouse.events.move, false);

  window.addEventListener('touchstart', Mouse.events.down, false);

  window.addEventListener('touchstop', Mouse.events.up, false);

  side = hypotenuse(canvas.width, canvas.height) / 6;

  geometry = new THREE.SphereGeometry(side / 1.4, side, side);

  material = new THREE.MeshBasicMaterial({});

  cubes = [];

  xside = side;

  yside = side;

  sidehypotenuse = hypotenuse(side, side);

  offset = 75;

  cubes2 = [];

  for (x = _i = _ref = camera.left * 1.5, _ref1 = camera.right * 1.5, _ref2 = xside * 1; _ref2 > 0 ? _i <= _ref1 : _i >= _ref1; x = _i += _ref2) {
    for (y = _j = _ref3 = camera.bottom * 1.8 - x, _ref4 = camera.top * 1.5 - x; yside > 0 ? _j <= _ref4 : _j >= _ref4; y = _j += yside) {
      cubes2.push(new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
        color: 0x000000,
        opacity: 0.5
      })));
      cubes2[cubes2.length - 1].position.x = x - 0.000005 * x;
      cubes2[cubes2.length - 1].position.y = y;
      cubes2[cubes2.length - 1].position.z = x + y;
      scene.add(cubes2[cubes2.length - 1]);
      cubes.push(new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
        opacity: 0.9
      })));
      cubes[cubes.length - 1].position.x = x;
      cubes[cubes.length - 1].position.y = y;
      cubes[cubes.length - 1].position.z = x + y;
      scene.add(cubes[cubes.length - 1]);
    }
  }

  camera.position.set(0, 0, side * 10);

  camera.up = new THREE.Vector3(0, 1, 0);

  animloop = function() {
    var i, _k, _ref5;
    animloop.id = requestAnimationFrame(animloop);
    t = (Date.now() - start) / 1000 + seed;
    frame++;
    camera.position.set(side * 10, side * 10, -side * 10);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    if (Mouse.down) {
      Mouse.held++;
    }
    for (i = _k = 0, _ref5 = cubes.length; 0 <= _ref5 ? _k < _ref5 : _k > _ref5; i = 0 <= _ref5 ? ++_k : --_k) {
      cubes[i].rotation.x = sin(PI / 2 * 0) * PI / 4 + 0 * PI / 4 + sin(t * 0.6) * 0.000013;
      cubes[i].rotation.z = 0.00001 * sin(t / 300);
      cubes[i].rotation.y = 0.00055 * sin(t / 6);
    }
    return renderer.render(scene, camera);
  };

  animloop();

}).call(this);

</script>
  <script id="jsbin-source-html" type="text/html"><!DOCTYPE html>
<html>
<head>
<script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r67/three.min.js"><\/script>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta charset="utf-8">
  <title>blind</title>
</head>
<body>

</body>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3889624-4']);
  _gaq.push(['_trackPageview']);

  (function () {
    var ga = document.createElement('script');
    ga.type = 'text/javascript';
    ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(ga, s);
  })();
<\/script>
</html></script>
  <script id="jsbin-source-css" type="text/css">body, canvas {
  margin: 0;
  border: 0;
  padding: 0;
  background-color:black;
  cursor: crosshair;
}
canvas {
  position: fixed;
}</script>
  <script id="jsbin-source-javascript" type="text/coffeescript">t = 0
start = Date.now()
seed = Math.random()*1000
frame = 0
PI = Math.PI
sin = (a) -> Math.sin(a)
cos = (a) -> Math.cos(a)
abs = (a) -> Math.abs(a)
sqrt = (a) -> Math.sqrt(a)
hypotenuse = (a, b) -> Math.sqrt(a*a+b*b)
distance = (x1, y1, x2, y2) -> hypotenuse(x2-x1, y2-y1)
scene = new THREE.Scene()
camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -50*100, 30*1000 )
# camera = new THREE.PerspectiveCamera 37.8, window.innerWidth/window.innerHeight, 0.1, 1000
renderer = new THREE.WebGLRenderer()
canvas = document.createElement 'canvas'
ctx = canvas.getContext '2d'
do resizeHandler = ->
  camera.left = canvas.left = window.innerWidth / - 2
  camera.right = canvas.right = window.innerWidth / 2
  camera.bottom = canvas.bottom = window.innerHeight / -2
  camera.top = canvas.top = window.innerHeight / 2
  camera.aspect = window.innerWidth / window.innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize window.innerWidth, window.innerHeight
  canvas.width = window.innerWidth
  canvas.height = window.innerHeight
  canvas.hyp = hypotenuse canvas.width, canvas.height
window.addEventListener 'resize', resizeHandler, false
document.body.appendChild renderer.domElement
Mouse =
  down: false
  held: 0
  x: canvas.width/2
  y: canvas.height/2
  x0: 0
  y0: 0
  events:
    move: (e) ->
      if "touches" of e
        e.preventDefault()
        e = e.touches[0]
      Mouse.x = (Mouse.x + e.pageX) * 0.5
      Mouse.y = (Mouse.y + e.pageY) * 0.5
      Mouse.x0 = Mouse.x - canvas.width/2
      Mouse.y0 = Mouse.y - canvas.height/2
    down: (e) ->
      Mouse.down = not Mouse.down
    up: (e) ->
      Mouse.down = not Mouse.down

window.addEventListener 'mousemove', Mouse.events.move, false
window.addEventListener 'mousedown', Mouse.events.down, false
window.addEventListener 'mouseup', Mouse.events.up, false
window.addEventListener 'touchmove', Mouse.events.move, false
window.addEventListener 'touchstart', Mouse.events.down, false
window.addEventListener 'touchstop', Mouse.events.up, false
side = hypotenuse(canvas.width,canvas.height)/6
# side = 50
# geometry = new THREE.BoxGeometry side, side, side
geometry = new THREE.SphereGeometry side/1.4, side, side
material = new THREE.MeshBasicMaterial {
}
cubes = []
xside = side
yside = side
sidehypotenuse = hypotenuse side, side
offset = 75

cubes2 = []
for x in [camera.left*1.5 .. camera.right*1.5] by xside*1 # by 2.5#1.5
  for y in [camera.bottom*1.8 - x .. camera.top*1.5 - x] by yside # by 2.5#1.5
#     for z in [0 .. 0] by 5
    cubes2.push new THREE.Mesh geometry, new THREE.MeshBasicMaterial(
      color: 0x000000
#       wireframeLinewidth: 9
#       wireframe: true
#       transparent: true
      opacity: 0.5
      )
    cubes2[cubes2.length-1].position.x = x - 0.000005*x # + (x+y)/6
    cubes2[cubes2.length-1].position.y = y
    cubes2[cubes2.length-1].position.z = (x+y)
    scene.add cubes2[cubes2.length-1]
    
    cubes.push new THREE.Mesh geometry, new THREE.MeshBasicMaterial(
#       color: 0x00ffff
#       wireframeLinewidth: 9
#       wireframe: true
#       transparent: true
      opacity: 0.9
      )
    cubes[cubes.length-1].position.x = x # + (x+y)/6
    cubes[cubes.length-1].position.y = y
    cubes[cubes.length-1].position.z = (x+y)
    scene.add cubes[cubes.length-1]

camera.position.set(0,0,side*10)
camera.up = new THREE.Vector3(0,1,0)
animloop = ->
  animloop.id = requestAnimationFrame animloop
  t = (Date.now() - start)/1000 + seed
  frame++
  camera.position.set(side*10,side*10,-side*10)
  camera.lookAt new THREE.Vector3(0,0,0)
  Mouse.held++ if Mouse.down
  for i in [0 ... cubes.length]
    cubes[i].rotation.x = sin(PI/2*0)*PI/4 + 0*PI/4 + sin(t*0.6)*0.000013
    cubes[i].rotation.z = 0.00001*sin(t/300)
    cubes[i].rotation.y = 0.00055*sin(t/6)
  renderer.render scene, camera

animloop()
# console.dir(cubes[0])</script>
</body>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-3889624-4']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script');
  ga.type = 'text/javascript';
  ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0];
  s.parentNode.insertBefore(ga, s);
})();
</script>

</html>